"use strict";(self.webpackChunkalexmercerind_github_io=self.webpackChunkalexmercerind_github_io||[]).push([[673],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8211:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return p}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],l={slug:"alexmercerind",title:"C++'s <future>, making async C callbacks functions sync & enjoyable asynchronous programming",tags:["c++","std::async","multi-threading","async"]},s=void 0,c={permalink:"/blog/alexmercerind",source:"@site/blog/2022-05-21-cpp-future-async-sync.md",title:"C++'s <future>, making async C callbacks functions sync & enjoyable asynchronous programming",description:"I use `` header in C++ very-very often in my code everywhere at this point & wanted to share what's so cool in it.",date:"2022-05-21T00:00:00.000Z",formattedDate:"May 21, 2022",tags:[{label:"c++",permalink:"/blog/tags/c"},{label:"std::async",permalink:"/blog/tags/std-async"},{label:"multi-threading",permalink:"/blog/tags/multi-threading"},{label:"async",permalink:"/blog/tags/async"}],readingTime:5.815,truncated:!0,authors:[],frontMatter:{slug:"alexmercerind",title:"C++'s <future>, making async C callbacks functions sync & enjoyable asynchronous programming",tags:["c++","std::async","multi-threading","async"]}},u={authorsImageUrls:[]},p=[{value:"Code",id:"code",level:3},{value:"Equivalents in HLL Dart or JavaScript",id:"equivalents-in-hll-dart-or-javascript",level:3},{value:"Making a C async callback based function sync",id:"making-a-c-async-callback-based-function-sync",level:3}],d={toc:p};function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"I use ",(0,o.kt)("a",{parentName:"p",href:"https://cplusplus.com/reference/future"},(0,o.kt)("inlineCode",{parentName:"a"},"<future>"))," header in C++ very-very often in my code everywhere at this point & wanted to share what's so cool in it."),(0,o.kt)("p",null,"Generally, I don't really like classic way of handling ",(0,o.kt)("inlineCode",{parentName:"p"},"Thread"),"s, so much to worry about, spawning, running or joining."),(0,o.kt)("p",null,"What I find more elegant is:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"C#/.NET's ",(0,o.kt)("inlineCode",{parentName:"li"},"async"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"await")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"Task")),(0,o.kt)("li",{parentName:"ul"},"JavaScript's ",(0,o.kt)("inlineCode",{parentName:"li"},"async"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"await")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"Promise")," (I know JS is single-threaded, but still)"),(0,o.kt)("li",{parentName:"ul"},"Dart's ",(0,o.kt)("inlineCode",{parentName:"li"},"async"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"await")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"Future"),' (again, not actually "multi-threading").')),(0,o.kt)("p",null,"I got to know about ",(0,o.kt)("inlineCode",{parentName:"p"},"std::future")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"std::promise")," in C++ 11 few years back & they're quite the same in terms of how they're used in code. My happiness couldn't be greater."),(0,o.kt)("p",null,"Just see how elegant this looks:"),(0,o.kt)("h3",{id:"code"},"Code"),(0,o.kt)("p",null,"Use ",(0,o.kt)("inlineCode",{parentName:"p"},"std::async")," function to spawn a new thread and pass a function to it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <future>\n#include <iostream>\n\nint32_t main() {\n\n  auto future = std::async([&]() {\n    std::cout << "A std::future came to life!\\n";\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::cout << "Hello from std::future & I\'m 2 seconds late!\\n";\n  });\n\n  std::this_thread::sleep_for(std::chrono::seconds(1));\n  std::cout << "Hey, I\'ll be first on the console!\\n";\n  return 0;\n}\n')),(0,o.kt)("p",null,"Don't late that capturing lambda confuse you."),(0,o.kt)("p",null,"Something like this will be up on your terminal:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cmd"},"A std::future came to life!\nHey, I'll be first on the console!\nHello from std::future & I'm 2 seconds late!\na_variable_declared_outside: 69420\n")),(0,o.kt)("div",{className:"admonition admonition-warning alert alert--danger"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"warning")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Always keep a reference accessible to yo to the ",(0,o.kt)("inlineCode",{parentName:"p"},"std::future")," returned by the ",(0,o.kt)("inlineCode",{parentName:"p"},"std::async"),".\nOtherwise, your function passed will not launch on separate thread & just execute sync-ly."),(0,o.kt)("p",{parentName:"div"},"The other day, I was spawning ",(0,o.kt)("inlineCode",{parentName:"p"},"std::future"),"s to do various things concurrently in a ",(0,o.kt)("inlineCode",{parentName:"p"},"for-loop")," and noticed that everything was being executed synchronously. Then I came to know that I need to store their reference somewhere to be able to access them later. Added a ",(0,o.kt)("inlineCode",{parentName:"p"},"std::vector<std::future<void>>")," in my case (where I pushed all returned ",(0,o.kt)("inlineCode",{parentName:"p"},"std::future"),"s)."),(0,o.kt)("p",{parentName:"div"},"Here let's just remove the ",(0,o.kt)("inlineCode",{parentName:"p"},"future")," variable from above code:"),(0,o.kt)("pre",{parentName:"div"},(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <future>\n#include <iostream>\n\nint32_t main() {\n  std::async([&]() {\n    std::cout << "A std::future came to life!\\n";\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::cout << "Hello from std::future & I\'m 2 seconds late!\\n";\n  });\n\n  std::this_thread::sleep_for(std::chrono::seconds(1));\n  std::cout << "Hey, I\'ll be first on the console!\\n";\n  return 0;\n}\n')),(0,o.kt)("p",{parentName:"div"},"Notice how \"Hey, I'll be first on the console!\" came in last. Something we didn't expect."),(0,o.kt)("p",{parentName:"div"},"Takes away the whole purpose."),(0,o.kt)("pre",{parentName:"div"},(0,o.kt)("code",{parentName:"pre"},"A std::future came to life!\nHello from std::future & I'm 2 seconds late!\na_variable_declared_outside: 69420\nHey, I'll be first on the console!\n")))),(0,o.kt)("h3",{id:"equivalents-in-hll-dart-or-javascript"},"Equivalents in HLL Dart or JavaScript"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"How simple is that.")," A separate thread launched with ",(0,o.kt)("inlineCode",{parentName:"p"},"std::async")," & do whatever with it. This syntax is quite nice & familiar to how I'm trained with Dart/JavaScript."),(0,o.kt)("p",null,"Take equivalent Dart for example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-dart"},"void main() async {\n  () async {\n    print('An async function came to life!');\n    await Future.delayed(const Duration(seconds: 2));\n    print('Hello from async function & I\\'m 2 seconds late!');\n  }();\n  await Future.delayed(const Duration(seconds: 1));\n  print('Hey, I\\'ll be first on the console!');\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"An async function came to life!\nHey, I'll be first on the console!\nHello from async function & I'm 2 seconds late!\n")),(0,o.kt)("p",null,"This ",(0,o.kt)("a",{parentName:"p",href:"https://cplusplus.com/reference/future/future/"},(0,o.kt)("inlineCode",{parentName:"a"},"std::future"))," stuff in C++ now may seem really cool to you, but I still haven't noticed any analog of ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"},(0,o.kt)("inlineCode",{parentName:"a"},"Promise.all"))," from JavaScript in it yet."),(0,o.kt)("p",null,"Though, simple thread create/start/join API, is also good in some situations like doing event-polling in background or just spinning up something consistently while UI is visible. Other than that, it just becomes a pain in my opinion to handle if we have a lot of async operations to worry about & handling of tasks."),(0,o.kt)("h3",{id:"making-a-c-async-callback-based-function-sync"},"Making a C async callback based function sync"),(0,o.kt)("p",null,"If you've written JavaScript, I think you know how some libraries still ask for a function as argument and call it back once some heavy/network-related operation is done. This reminds me of ",(0,o.kt)("inlineCode",{parentName:"p"},"fs")," (callback based filesystem API) and ",(0,o.kt)("inlineCode",{parentName:"p"},"fs/promise")," (",(0,o.kt)("inlineCode",{parentName:"p"},"Promise"),"s based filesystem API) from Node.js. Converting a old callback based API into shiny new async API is something I would do to sooth my soul."),(0,o.kt)("p",null,"An equivalent for this exists in Dart to make a function sync: ",(0,o.kt)("a",{parentName:"p",href:"https://api.dartlang.org/stable/dart-async/Completer-class.html"},"Completer"),"."),(0,o.kt)("p",null,"I had a similar situation in C/C++, ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/alexmercerind/dart_vlc/blob/3b0571743f0ed2f90aa52ab92e955b55cd10d0dd/core/media_source/media.cc#L84-L87"},'where I needed to "wait" for some async operation to finish before I could return the result from my function'),". I didn't know any solution but ",(0,o.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/thread/promise"},(0,o.kt)("inlineCode",{parentName:"a"},"std::promise"))," from ",(0,o.kt)("a",{parentName:"p",href:"https://cplusplus.com/reference/future/"},(0,o.kt)("inlineCode",{parentName:"a"},"<future>"))," came in very-very handy."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Let's take this code:")),(0,o.kt)("p",null,"We want to wait for the value that is being returned from ",(0,o.kt)("inlineCode",{parentName:"p"},"a_long_running_function_that_returns_result_in_callback")," inside callback from another thread before proceeding to print ",(0,o.kt)("inlineCode",{parentName:"p"},'"This should not execute early!!!\\n"')," on console."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <future>\n#include <iostream>\n\n// Let\'s say we have this function which takes a lot of time to execute &\n// returns the final result in the passed [callback] from another thread.\n// I\'m sure a lot of C/C++ librares like this are in existence.\n//\n// We need to wait for the result outside the passed callback.\n//\n// A place to demonstrate awesomeness of `std::promise`.\nvoid a_long_running_function_that_returns_result_in_callback(\n    void (*callback)(int)) {\n  std::thread([=]() {\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    callback(69420);\n  }).detach();\n}\n\nvoid print_the_value(int value) {\n  std::cout << "The value is: " << value << "\\n";\n}\n\nvoid main() {\n  a_long_running_function_that_returns_result_in_callback(print_the_value);\n  std::cout << "This should not execute early!!!\\n";\n  std::cin.get();\n}\n')),(0,o.kt)("p",null,"Output of this on your terminal will be:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"This should not execute early!!!\nThe value is: 69420\n")),(0,o.kt)("p",null,"The order is clearly messed up."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Let's bring ",(0,o.kt)("a",{parentName:"strong",href:"https://en.cppreference.com/w/cpp/thread/promise"},(0,o.kt)("inlineCode",{parentName:"a"},"std::promise"))," to the rescue:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <future>\n#include <iostream>\n\n// Don't kill me for using global variables. C'mon it's C API that we're trying\n// to wrap.\nauto g_promise = std::promise<int>();\n\n// Let's say we have this function which takes a lot of time to execute &\n// returns the final result in the passed [callback] from another thread.\n// I'm sure a lot of C/C++ librares like this are in existence.\n//\n// We need to wait for the result outside the passed callback.\n//\n// A place to demonstrate awesomeness of `std::promise`.\nvoid a_long_running_function_that_returns_result_in_callback(\n    void (*callback)(int)) {\n  std::thread([=]() {\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    callback(69420);\n  }).detach();\n}\n\nvoid print_the_value(int value) {\n  std::cout << \"The value is: \" << value << \"\\n\";\n  // Set the value to the `std::future` corresponding to the promise.\n  // Cause the wait to be over.\n  g_promise.set_value(value);\n}\n\nvoid main() {\n  a_long_running_function_that_returns_result_in_callback(print_the_value);\n  // Wait until the promise is resolved.\n  g_promise.get_future().wait();\n  std::cout << \"This should not execute early!!!\\n\";\n\n  std::cin.get();\n}\n")),(0,o.kt)("p",null,"Notice how ",(0,o.kt)("inlineCode",{parentName:"p"},"std::promise::set_value")," is called from the callback.\nThen, ",(0,o.kt)("inlineCode",{parentName:"p"},"std::future::wait")," is called from the main thread to wait for the promise to be resolved."),(0,o.kt)("p",null,"Such a nice syntax. If you wish to get the value inside ",(0,o.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/thread/promise"},(0,o.kt)("inlineCode",{parentName:"a"},"std::promise"))," from the callback, you can use ",(0,o.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/thread/future/get"},(0,o.kt)("inlineCode",{parentName:"a"},"std::future::get"))," instead of the ",(0,o.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/thread/future/wait"},(0,o.kt)("inlineCode",{parentName:"a"},"std::future::wait")),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'int a_long_running_function_that_returns_same_result_without_callback() {\n  a_long_running_function_that_returns_result_in_callback(print_the_value);\n  // Wait until the promise is resolved & return from this wrapper function.\n  return g_promise.get_future().get();\n}\n\nvoid main() {\n  std::cout\n      << "Returned value: "\n      << a_long_running_function_that_returns_same_result_without_callback()\n      << "\\n";\n  std::cin.get();\n}\n')),(0,o.kt)("p",null,"There are also following things to note, which one may find useful:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://en.cppreference.com/w/cpp/thread/future/wait_for"},(0,o.kt)("inlineCode",{parentName:"a"},"std::future::wait_for")),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://en.cppreference.com/w/cpp/thread/future/wait_until"},(0,o.kt)("inlineCode",{parentName:"a"},"std::future::wait_until")),".")),(0,o.kt)("p",null,"Don't spam Rust is better in comments (oh, there are no comments right now). I'm staying with C++ for now."))}m.isMDXComponent=!0}}]);